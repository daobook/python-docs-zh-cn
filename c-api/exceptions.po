# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
# Translators:
# cdarlint <cdarling@126.com>, 2021
# allenjuly7 <allenjuly7@astu.fun>, 2021
# Ziqi Wang <ziqiwang.xust@gmail.com>, 2021
# Yi Cao <1783250036@qq.com>, 2021
# jsgang <jsgang9@gmail.com>, 2021
# Freesand Leo <yuqinju@163.com>, 2021
# Pandaaaa906 <ye.pandaaaa906@gmail.com>, 2021
# ppcfish <ppcfish@gmail.com>, 2021
# jaystone776 <1732865113@qq.com>, 2021
# Jiuh-star <jiuh.star@gmail.com>, 2021
# helloworldSB <warningfor163@foxmail.com>, 2021
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-21 14:44+0800\n"
"PO-Revision-Date: 2021-06-28 00:48+0000\n"
"Last-Translator: helloworldSB <warningfor163@foxmail.com>, 2021\n"
"Language: zh_CN\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-"
"doc/teams/5390/zh_CN/)\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../c-api/exceptions.rst:8
msgid "Exception Handling"
msgstr "异常处理"

#: ../../c-api/exceptions.rst:10
msgid ""
"The functions described in this chapter will let you handle and raise "
"Python exceptions.  It is important to understand some of the basics of "
"Python exception handling.  It works somewhat like the POSIX "
":c:data:`errno` variable: there is a global indicator (per thread) of the"
" last error that occurred.  Most C API functions don't clear this on "
"success, but will set it to indicate the cause of the error on failure.  "
"Most C API functions also return an error indicator, usually ``NULL`` if "
"they are supposed to return a pointer, or ``-1`` if they return an "
"integer (exception: the :c:func:`PyArg_\\*` functions return ``1`` for "
"success and ``0`` for failure)."
msgstr ""
"本章描述的函数将让你处理和触发 Python 异常。了解一些 Python 异常处理的基本知识是很重要的。 它的工作原理有点像 POSIX 的 "
":c:data:`errno` 变量：（每个线程）有一个全局指示器显示最近发生的错误。 大多数 C API "
"函数不会在成功时理会它，但会在失败时设置它来指示错误的原因。 多数 C API 函数也返回一个错误指示器，如果它们应该返回一个指针，通常返回 "
"``NULL``，如果返回一个整数，则返回 ``-1`` (例外: :c:func:`PyArg_\\*` 函数成功时返回 ``1`` "
"而失败时返回 ``0``)。"

#: ../../c-api/exceptions.rst:20
msgid ""
"Concretely, the error indicator consists of three object pointers: the "
"exception's type, the exception's value, and the traceback object.  Any "
"of those pointers can be ``NULL`` if non-set (although some combinations "
"are forbidden, for example you can't have a non-``NULL`` traceback if the"
" exception type is ``NULL``)."
msgstr ""
"具体地说，错误指示器由三个对象指针组成：异常的类型，异常的值，和回溯对象。如果没有错误被设置，这些指针都可以是 ``NULL`` "
"（尽管一些组合使禁止的，例如，如果异常类型是 ``NULL``，你不能有一个非 ``NULL`` 的回溯）。"

#: ../../c-api/exceptions.rst:26
msgid ""
"When a function must fail because some function it called failed, it "
"generally doesn't set the error indicator; the function it called already"
" set it.  It is responsible for either handling the error and clearing "
"the exception or returning after cleaning up any resources it holds (such"
" as object references or memory allocations); it should *not* continue "
"normally if it is not prepared to handle the error.  If returning due to "
"an error, it is important to indicate to the caller that an error has "
"been set.  If the error is not handled or carefully propagated, "
"additional calls into the Python/C API may not behave as intended and may"
" fail in mysterious ways."
msgstr ""
"当一个函数由于它调用的某个函数失败而必须失败时，通常不会设置错误指示器；它调用的那个函数已经设置了它。而它负责处理错误和清理异常，或在清除其拥有的所有资源后返回（如对象应用或内存分配）。如果不准备处理异常，则"
" *不* 应该正常地继续。如果是由于一个错误返回，那么一定要向调用者表明已经设置了错误。如果错误没有得到处理或小心传播，对 Python/C "
"API的其它调用可能不会有预期的行为，并且可能会以某种神秘的方式失败。"

#: ../../c-api/exceptions.rst:37
msgid ""
"The error indicator is **not** the result of :func:`sys.exc_info()`. The "
"former corresponds to an exception that is not yet caught (and is "
"therefore still propagating), while the latter returns an exception after"
" it is caught (and has therefore stopped propagating)."
msgstr ""
"错误指示器 **不是** :func:`sys.exc_info()` "
"的执行结果。前者对应尚未捕获的异常（异常还在传播），而后者在捕获异常后返回这个异常（异常已经停止传播）。"

#: ../../c-api/exceptions.rst:44
msgid "Printing and clearing"
msgstr "打印和清理"

#: ../../c-api/exceptions.rst:49
msgid ""
"Clear the error indicator.  If the error indicator is not set, there is "
"no effect."
msgstr "清除错误指示器。如果没有设置错误指示器，则不会有作用。"

#: ../../c-api/exceptions.rst:55
msgid ""
"Print a standard traceback to ``sys.stderr`` and clear the error "
"indicator. **Unless** the error is a ``SystemExit``, in that case no "
"traceback is printed and the Python process will exit with the error code"
" specified by the ``SystemExit`` instance."
msgstr ""
"将标准回溯打印到 ``sys.stderr`` 并清除错误指示器。**除非** 错误是 "
"``SystemExit``，这种情况下不会打印回溯进程，且会退出 Python 进程，并显示 ``SystemExit`` 实例指定的错误代码。"

#: ../../c-api/exceptions.rst:60
msgid ""
"Call this function **only** when the error indicator is set.  Otherwise "
"it will cause a fatal error!"
msgstr "只有在错误指示器被设置时才需要调用这个函数，否则这会导致错误！"

#: ../../c-api/exceptions.rst:63
msgid ""
"If *set_sys_last_vars* is nonzero, the variables :data:`sys.last_type`, "
":data:`sys.last_value` and :data:`sys.last_traceback` will be set to the "
"type, value and traceback of the printed exception, respectively."
msgstr ""
"如果 *set_sys_last_vars* 非零，则变量 "
":data:`sys.last_type`，:data:`sys.last_value` 和 :data:`sys.last_traceback`"
" 将分别设置为打印异常的类型，值和回溯。"

#: ../../c-api/exceptions.rst:70
msgid "Alias for ``PyErr_PrintEx(1)``."
msgstr "``PyErr_PrintEx(1)`` 的别名。"

#: ../../c-api/exceptions.rst:75
msgid ""
"Call :func:`sys.unraisablehook` using the current exception and *obj* "
"argument."
msgstr "使用当前异常和 *obj* 参数调用 :func:`sys.unraisablehook`。"

#: ../../c-api/exceptions.rst:78
msgid ""
"This utility function prints a warning message to ``sys.stderr`` when an "
"exception has been set but it is impossible for the interpreter to "
"actually raise the exception.  It is used, for example, when an exception"
" occurs in an :meth:`__del__` method."
msgstr ""
"当设置了异常，但解释器不可能实际地触发异常时，这个实用函数向 ``sys.stderr`` 打印一个警告信息。例如，当 "
":meth:`__del__` 方法中发生异常时使用这个函数。"

#: ../../c-api/exceptions.rst:83
msgid ""
"The function is called with a single argument *obj* that identifies the "
"context in which the unraisable exception occurred. If possible, the repr"
" of *obj* will be printed in the warning message."
msgstr "该函数使用单个参数 *obj* 进行调用，该参数标识发生不可触发异常的上下文。如果可能，*obj* 的报告将打印在警告消息中。"

#: ../../c-api/exceptions.rst:87
msgid "An exception must be set when calling this function."
msgstr "调用此函数时必须设置一个异常。"

#: ../../c-api/exceptions.rst:91
msgid "Raising exceptions"
msgstr "抛出异常"

#: ../../c-api/exceptions.rst:93
msgid ""
"These functions help you set the current thread's error indicator. For "
"convenience, some of these functions will always return a ``NULL`` "
"pointer for use in a ``return`` statement."
msgstr "这些函数可帮助你设置当前线程的错误指示器。为了方便起见，一些函数将始终返回 ``NULL`` 指针，以便用于 ``return`` 语句。"

#: ../../c-api/exceptions.rst:100
#, fuzzy
msgid ""
"This is the most common way to set the error indicator.  The first "
"argument specifies the exception type; it is normally one of the standard"
" exceptions, e.g. :c:data:`PyExc_RuntimeError`.  You need not increment "
"its reference count. The second argument is an error message; it is "
"decoded from ``'utf-8'``."
msgstr ""
"这是设置错误指示器最常用的方法。第一个参数指定异常类型；它通常是标准异常之一，e.g. "
":c:data:`PyExc_RuntimeError`。你不需要增加它的引用计数。第二个参数是错误信息，它解码自 ``'utf-8'``。"

#: ../../c-api/exceptions.rst:108
msgid ""
"This function is similar to :c:func:`PyErr_SetString` but lets you "
"specify an arbitrary Python object for the \"value\" of the exception."
msgstr "此函数类似于 :c:func:`PyErr_SetString`，但是允许你为异常的“值”指定任意一个 Python 对象。"

#: ../../c-api/exceptions.rst:114
msgid ""
"This function sets the error indicator and returns ``NULL``.  *exception*"
" should be a Python exception class.  The *format* and subsequent "
"parameters help format the error message; they have the same meaning and "
"values as in :c:func:`PyUnicode_FromFormat`. *format* is an ASCII-encoded"
" string."
msgstr ""
"这个函数设置了一个错误指示器并且返回了 ``NULL``，*exception* 应当是一个 Python 中的异常类。*format* "
"和随后的形参会帮助格式化这个错误的信息；它们与 :c:func:`PyUnicode_FromFormat` 有着相同的含义和值。*format*"
" 是一个ASCII编码的字符串。"

#: ../../c-api/exceptions.rst:123
msgid ""
"Same as :c:func:`PyErr_Format`, but taking a :c:type:`va_list` argument "
"rather than a variable number of arguments."
msgstr "和 :c:func:`PyErr_Format` 相同，但它接受一个 :c:type:`va_list` 类型的参数而不是可变数量的参数集。"

#: ../../c-api/exceptions.rst:131
msgid "This is a shorthand for ``PyErr_SetObject(type, Py_None)``."
msgstr "这是 ``PyErr_SetObject(type, Py_None)`` 的简写。"

#: ../../c-api/exceptions.rst:136
msgid ""
"This is a shorthand for ``PyErr_SetString(PyExc_TypeError, message)``, "
"where *message* indicates that a built-in operation was invoked with an "
"illegal argument.  It is mostly for internal use."
msgstr ""
"这是 ``PyErr_SetString(PyExc_TypeError, message)`` 的简写，其中 *message* "
"指出使用了非法参数调用内置操作。它主要用于内部使用。"

#: ../../c-api/exceptions.rst:143
msgid ""
"This is a shorthand for ``PyErr_SetNone(PyExc_MemoryError)``; it returns "
"``NULL`` so an object allocation function can write ``return "
"PyErr_NoMemory();`` when it runs out of memory."
msgstr ""
"这是 ``PyErr_SetNone(PyExc_MemoryError)`` 的简写；它返回 ``NULL`` "
"，以便当内存耗尽时，对象分配函数可以写 ``return PyErr_NoMemory();`` 。"

#: ../../c-api/exceptions.rst:152
msgid ""
"This is a convenience function to raise an exception when a C library "
"function has returned an error and set the C variable :c:data:`errno`.  "
"It constructs a tuple object whose first item is the integer "
":c:data:`errno` value and whose second item is the corresponding error "
"message (gotten from :c:func:`strerror`), and then calls "
"``PyErr_SetObject(type, object)``.  On Unix, when the :c:data:`errno` "
"value is :const:`EINTR`, indicating an interrupted system call, this "
"calls :c:func:`PyErr_CheckSignals`, and if that set the error indicator, "
"leaves it set to that.  The function always returns ``NULL``, so a "
"wrapper function around a system call can write ``return "
"PyErr_SetFromErrno(type);`` when the system call returns an error."
msgstr ""
"这是个便捷函数，当 C 库函数返回错误并设置 :c:data:`errno` 时，这个函数会触发异常。它构造一个元组对象，其第一项是整数值 "
":c:data:`errno`，第二项是相应的错误消息（从 :c:func:`strerror` 获取），然后调用 "
"``PyErr_SetObject(type, object)``。在 Unix 上，当 :c:data:`errno` 值是 "
":const:`EINTR` ，即中断的系统调用时，这个函数会调用 :c:func:`PyErr_CheckSignals` "
"，如果设置了错误指示器，则将其设置为该值。该函数永远返回 ``NULL`` ，因此当系统调用返回错误时，围绕系统调用的包装函数可以写成 "
"``return PyErr_SetFromErrno(type);``。"

#: ../../c-api/exceptions.rst:166
msgid ""
"Similar to :c:func:`PyErr_SetFromErrno`, with the additional behavior "
"that if *filenameObject* is not ``NULL``, it is passed to the constructor"
" of *type* as a third parameter.  In the case of :exc:`OSError` "
"exception, this is used to define the :attr:`filename` attribute of the "
"exception instance."
msgstr ""
"类似于 :c:func:`PyErr_SetFromErrno` ，附加的行为是如果 *filenameObject* 不为 ``NULL`` "
"，它将作为第三个参数传递给 *type* 的构造函数。举个例子，在 :exc:`OSError` 异常中，*filenameObject* "
"将用来定义异常实例的 :attr:`filename` 属性。"

#: ../../c-api/exceptions.rst:175
msgid ""
"Similar to :c:func:`PyErr_SetFromErrnoWithFilenameObject`, but takes a "
"second filename object, for raising errors when a function that takes two"
" filenames fails."
msgstr ""
"类似于 :c:func:`PyErr_SetFromErrnoWithFilenameObject` ，但接受第二个 filename "
"对象，用于当一个接受两个 filename 的函数失败时触发错误。"

#: ../../c-api/exceptions.rst:184
msgid ""
"Similar to :c:func:`PyErr_SetFromErrnoWithFilenameObject`, but the "
"filename is given as a C string.  *filename* is decoded from the "
":term:`filesystem encoding and error handler`."
msgstr ""

#: ../../c-api/exceptions.rst:191
msgid ""
"This is a convenience function to raise :exc:`WindowsError`. If called "
"with *ierr* of :c:data:`0`, the error code returned by a call to "
":c:func:`GetLastError` is used instead.  It calls the Win32 function "
":c:func:`FormatMessage` to retrieve the Windows description of error code"
" given by *ierr* or :c:func:`GetLastError`, then it constructs a tuple "
"object whose first item is the *ierr* value and whose second item is the "
"corresponding error message (gotten from :c:func:`FormatMessage`), and "
"then calls ``PyErr_SetObject(PyExc_WindowsError, object)``. This function"
" always returns ``NULL``."
msgstr ""
"这是触发 :exc:`WindowsError` 的方便的函数。如果 *lerr* 为 :c:data:`0` ，则改用调用 "
":c:func:`GetLastError` 返回的错误代码。它调用 Win32 函数 :c:func:`FormatMessage` 来检索 "
"*ierr* 或 :c:func:`GetLastError` 给定的错误代码的 Windows 描述，然后构造一个元组对象，其第一项是 "
"*ierr* 值，第二项是相应的错误信息（从 :c:func:`FormatMessage` 获取），然后调用 "
"``PyErr_SetObject(PyExc_WindowsError, object)`` 。该函数永远返回 ``NULL`` 。"

#: ../../c-api/exceptions.rst:200 ../../c-api/exceptions.rst:208
#: ../../c-api/exceptions.rst:217 ../../c-api/exceptions.rst:225
#: ../../c-api/exceptions.rst:234 ../../c-api/exceptions.rst:243
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`可用性 <availability>`: Windows。"

#: ../../c-api/exceptions.rst:205
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErr`, with an additional "
"parameter specifying the exception type to be raised."
msgstr "类似于 :c:func:`PyErr_SetFromWindowsErr` ，额外的参数指定要触发的异常类型。"

#: ../../c-api/exceptions.rst:213
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErrWithFilenameObject`, but the "
"filename is given as a C string.  *filename* is decoded from the "
"filesystem encoding (:func:`os.fsdecode`)."
msgstr ""
"类似于 :c:func:`PyErr_SetFromWindowsErrWithFilenameObject` ，但是 filename 是以 C"
" 字符串形式给出的。 *filename* 是从文件系统编码（:func:`os.fsdecode`）解码出来的。"

#: ../../c-api/exceptions.rst:222
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErrWithFilenameObject`, with an "
"additional parameter specifying the exception type to be raised."
msgstr "类似于 :c:func:`PyErr_SetFromWindowsErrWithFilenameObject` ，额外参数指定要触发的异常类型。"

#: ../../c-api/exceptions.rst:230
msgid ""
"Similar to :c:func:`PyErr_SetExcFromWindowsErrWithFilenameObject`, but "
"accepts a second filename object."
msgstr ""
"类似于 :c:func:`PyErr_SetExcFromWindowsErrWithFilenameObject` ，但是接受第二个 "
"filename 对象。"

#: ../../c-api/exceptions.rst:240
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErrWithFilename`, with an "
"additional parameter specifying the exception type to be raised."
msgstr "类似于 :c:func:`PyErr_SetFromWindowsErrWithFilename` ，额外参数指定要触发的异常类型。"

#: ../../c-api/exceptions.rst:248
msgid ""
"This is a convenience function to raise :exc:`ImportError`. *msg* will be"
" set as the exception's message string. *name* and *path*, both of which "
"can be ``NULL``, will be set as the :exc:`ImportError`'s respective "
"``name`` and ``path`` attributes."
msgstr ""
"这是触发 :exc:`ImportError` 的便捷函数。 *msg* 将被设为异常的消息字符串。 *name* 和 *path* ，（都可以为"
" ``NULL`` ），将用来被设置 :exc:`ImportError` 对应的属性 ``name`` 和 ``path``。"

#: ../../c-api/exceptions.rst:258
msgid ""
"Set file, line, and offset information for the current exception.  If the"
" current exception is not a :exc:`SyntaxError`, then it sets additional "
"attributes, which make the exception printing subsystem think the "
"exception is a :exc:`SyntaxError`."
msgstr ""
"设置当前异常的文件，行和偏移信息。如果当前异常不是 :exc:`SyntaxError` ，则它设置额外的属性，使异常打印子系统认为异常是 "
":exc:`SyntaxError`。"

#: ../../c-api/exceptions.rst:268
msgid ""
"Like :c:func:`PyErr_SyntaxLocationObject`, but *filename* is a byte "
"string decoded from the :term:`filesystem encoding and error handler`."
msgstr ""

#: ../../c-api/exceptions.rst:276
msgid ""
"Like :c:func:`PyErr_SyntaxLocationEx`, but the col_offset parameter is "
"omitted."
msgstr "与 :c:func:`PyErr_SyntaxLocationEx` 类似，但省略了参数 col_offset。"

#: ../../c-api/exceptions.rst:282
msgid ""
"This is a shorthand for ``PyErr_SetString(PyExc_SystemError, message)``, "
"where *message* indicates that an internal operation (e.g. a Python/C API"
" function) was invoked with an illegal argument.  It is mostly for "
"internal use."
msgstr ""
"这是 ``PyErr_SetString(PyExc_SystemError, message)`` 的缩写，其中 *message* "
"表示使用了非法参数调用内部操作（例如，Python/C API 函数）。它主要用于内部使用。"

#: ../../c-api/exceptions.rst:289
msgid "Issuing warnings"
msgstr "发出警告"

#: ../../c-api/exceptions.rst:291
msgid ""
"Use these functions to issue warnings from C code.  They mirror similar "
"functions exported by the Python :mod:`warnings` module.  They normally "
"print a warning message to *sys.stderr*; however, it is also possible "
"that the user has specified that warnings are to be turned into errors, "
"and in that case they will raise an exception.  It is also possible that "
"the functions raise an exception because of a problem with the warning "
"machinery. The return value is ``0`` if no exception is raised, or ``-1``"
" if an exception is raised.  (It is not possible to determine whether a "
"warning message is actually printed, nor what the reason is for the "
"exception; this is intentional.)  If an exception is raised, the caller "
"should do its normal exception handling (for example, :c:func:`Py_DECREF`"
" owned references and return an error value)."
msgstr ""
"这些函数可以从 C 代码中发出警告。它们仿照了由 Python 模块 :mod:`warnings` 导出的那些函数。它们通常向 "
"*sys.stderr* "
"打印一条警告信息；当然，用户也有可能已经指定将警告转换为错误，在这种情况下，它们将触发异常。也有可能由于警告机制出现问题，使得函数触发异常。如果没有触发异常，返回值为"
" ``0`` ；如果触发异常，返回值为 "
"``-1``。（无法确定是否实际打印了警告信息，也无法确定异常触发的原因。这是故意为之）。如果触发了异常，调用者应该进行正常的异常处理（例如，:c:func:`Py_DECREF`"
" 持有引用并返回一个错误值）。"

#: ../../c-api/exceptions.rst:306
msgid ""
"Issue a warning message.  The *category* argument is a warning category "
"(see below) or ``NULL``; the *message* argument is a UTF-8 encoded "
"string.  *stack_level* is a positive number giving a number of stack "
"frames; the warning will be issued from the  currently executing line of "
"code in that stack frame.  A *stack_level* of 1 is the function calling "
":c:func:`PyErr_WarnEx`, 2 is  the function above that, and so forth."
msgstr ""
"发出一个警告信息。参数 *category* 是一个警告类别（见下面）或 ``NULL`` ； *message* 是一个 UTF-8 "
"编码的字符串。 *stack_level* 是一个给出栈帧数量的正数；警告将从该栈帧中当前正在执行的代码行发出。 *stack_level* 为 "
"1 的是调用 :c:func:`PyErr_WarnEx` 的函数，2 是在此之上的函数，以此类推。"

#: ../../c-api/exceptions.rst:313
msgid ""
"Warning categories must be subclasses of :c:data:`PyExc_Warning`; "
":c:data:`PyExc_Warning` is a subclass of :c:data:`PyExc_Exception`; the "
"default warning category is :c:data:`PyExc_RuntimeWarning`. The standard "
"Python warning categories are available as global variables whose names "
"are enumerated at :ref:`standardwarningcategories`."
msgstr ""
"警告类别必须是 :c:data:`PyExc_Warning` 的子类， :c:data:`PyExc_Warning` 是 "
":c:data:`PyExc_Exception` 的子类；默认警告类别是 :c:data:`PyExc_RuntimeWarning` 。标准 "
"Python 警告类别作为全局变量可用，所有其名称见 :ref:`standardwarningcategories` 。"

#: ../../c-api/exceptions.rst:319
msgid ""
"For information about warning control, see the documentation for the "
":mod:`warnings` module and the :option:`-W` option in the command line "
"documentation.  There is no C API for warning control."
msgstr "有关警告控制的信息，参见模块文档 :mod:`warnings` 和命令行文档中的 :option:`-W` 选项。没有用于警告控制的 C API。"

#: ../../c-api/exceptions.rst:325
msgid ""
"Much like :c:func:`PyErr_SetImportError` but this function allows for "
"specifying a subclass of :exc:`ImportError` to raise."
msgstr ""
"和 :c:func:`PyErr_SetImportError` 很类似，但这个函数允许指定一个 :exc:`ImportError` "
"的子类来触发。"

#: ../../c-api/exceptions.rst:333
msgid ""
"Issue a warning message with explicit control over all warning "
"attributes.  This is a straightforward wrapper around the Python function"
" :func:`warnings.warn_explicit`, see there for more information.  The "
"*module* and *registry* arguments may be set to ``NULL`` to get the "
"default effect described there."
msgstr ""

#: ../../c-api/exceptions.rst:344
msgid ""
"Similar to :c:func:`PyErr_WarnExplicitObject` except that *message* and "
"*module* are UTF-8 encoded strings, and *filename* is decoded from the "
":term:`filesystem encoding and error handler`."
msgstr ""

#: ../../c-api/exceptions.rst:351
msgid ""
"Function similar to :c:func:`PyErr_WarnEx`, but use "
":c:func:`PyUnicode_FromFormat` to format the warning message.  *format* "
"is an ASCII-encoded string."
msgstr ""

#: ../../c-api/exceptions.rst:360
msgid ""
"Function similar to :c:func:`PyErr_WarnFormat`, but *category* is "
":exc:`ResourceWarning` and it passes *source* to "
":func:`warnings.WarningMessage`."
msgstr ""

#: ../../c-api/exceptions.rst:367
msgid "Querying the error indicator"
msgstr "查询错误指示器"

#: ../../c-api/exceptions.rst:371
msgid ""
"Test whether the error indicator is set.  If set, return the exception "
"*type* (the first argument to the last call to one of the "
":c:func:`PyErr_Set\\*` functions or to :c:func:`PyErr_Restore`).  If not "
"set, return ``NULL``.  You do not own a reference to the return value, so"
" you do not need to :c:func:`Py_DECREF` it."
msgstr ""

#: ../../c-api/exceptions.rst:377
msgid "The caller must hold the GIL."
msgstr "呼叫者必须持有GIL。"

#: ../../c-api/exceptions.rst:381
msgid ""
"Do not compare the return value to a specific exception; use "
":c:func:`PyErr_ExceptionMatches` instead, shown below.  (The comparison "
"could easily fail since the exception may be an instance instead of a "
"class, in the case of a class exception, or it may be a subclass of the "
"expected exception.)"
msgstr ""

#: ../../c-api/exceptions.rst:389
msgid ""
"Equivalent to ``PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)``.  "
"This should only be called when an exception is actually set; a memory "
"access violation will occur if no exception has been raised."
msgstr ""

#: ../../c-api/exceptions.rst:396
msgid ""
"Return true if the *given* exception matches the exception type in *exc*."
"  If *exc* is a class object, this also returns true when *given* is an "
"instance of a subclass.  If *exc* is a tuple, all exception types in the "
"tuple (and recursively in subtuples) are searched for a match."
msgstr ""

#: ../../c-api/exceptions.rst:404
msgid ""
"Retrieve the error indicator into three variables whose addresses are "
"passed. If the error indicator is not set, set all three variables to "
"``NULL``.  If it is set, it will be cleared and you own a reference to "
"each object retrieved.  The value and traceback object may be ``NULL`` "
"even when the type object is not."
msgstr ""

#: ../../c-api/exceptions.rst:411
msgid ""
"This function is normally only used by code that needs to catch "
"exceptions or by code that needs to save and restore the error indicator "
"temporarily, e.g.::"
msgstr ""

#: ../../c-api/exceptions.rst:426
msgid ""
"Set  the error indicator from the three objects.  If the error indicator "
"is already set, it is cleared first.  If the objects are ``NULL``, the "
"error indicator is cleared.  Do not pass a ``NULL`` type and non-``NULL``"
" value or traceback.  The exception type should be a class.  Do not pass "
"an invalid exception type or value. (Violating these rules will cause "
"subtle problems later.)  This call takes away a reference to each object:"
" you must own a reference to each object before the call and after the "
"call you no longer own these references.  (If you don't understand this, "
"don't use this function.  I warned you.)"
msgstr ""

#: ../../c-api/exceptions.rst:438
msgid ""
"This function is normally only used by code that needs to save and "
"restore the error indicator temporarily.  Use :c:func:`PyErr_Fetch` to "
"save the current error indicator."
msgstr ""

#: ../../c-api/exceptions.rst:445
msgid ""
"Under certain circumstances, the values returned by :c:func:`PyErr_Fetch`"
" below can be \"unnormalized\", meaning that ``*exc`` is a class object "
"but ``*val`` is not an instance of the  same class.  This function can be"
" used to instantiate the class in that case.  If the values are already "
"normalized, nothing happens. The delayed normalization is implemented to "
"improve performance."
msgstr ""

#: ../../c-api/exceptions.rst:453
msgid ""
"This function *does not* implicitly set the ``__traceback__`` attribute "
"on the exception value. If setting the traceback appropriately is "
"desired, the following additional snippet is needed::"
msgstr ""

#: ../../c-api/exceptions.rst:464
msgid ""
"Retrieve the exception info, as known from ``sys.exc_info()``.  This "
"refers to an exception that was *already caught*, not to an exception "
"that was freshly raised.  Returns new references for the three objects, "
"any of which may be ``NULL``.  Does not modify the exception info state."
msgstr ""

#: ../../c-api/exceptions.rst:471
msgid ""
"This function is not normally used by code that wants to handle "
"exceptions. Rather, it can be used when code needs to save and restore "
"the exception state temporarily.  Use :c:func:`PyErr_SetExcInfo` to "
"restore or clear the exception state."
msgstr ""

#: ../../c-api/exceptions.rst:481
msgid ""
"Set the exception info, as known from ``sys.exc_info()``.  This refers to"
" an exception that was *already caught*, not to an exception that was "
"freshly raised.  This function steals the references of the arguments. To"
" clear the exception state, pass ``NULL`` for all three arguments. For "
"general rules about the three arguments, see :c:func:`PyErr_Restore`."
msgstr ""

#: ../../c-api/exceptions.rst:489
msgid ""
"This function is not normally used by code that wants to handle "
"exceptions. Rather, it can be used when code needs to save and restore "
"the exception state temporarily.  Use :c:func:`PyErr_GetExcInfo` to read "
"the exception state."
msgstr ""

#: ../../c-api/exceptions.rst:498
msgid "Signal Handling"
msgstr "信号处理"

#: ../../c-api/exceptions.rst:508
msgid "This function interacts with Python's signal handling."
msgstr ""

#: ../../c-api/exceptions.rst:510
msgid ""
"If the function is called from the main thread and under the main Python "
"interpreter, it checks whether a signal has been sent to the processes "
"and if so, invokes the corresponding signal handler.  If the "
":mod:`signal` module is supported, this can invoke a signal handler "
"written in Python."
msgstr ""

#: ../../c-api/exceptions.rst:515
msgid ""
"The function attempts to handle all pending signals, and then returns "
"``0``. However, if a Python signal handler raises an exception, the error"
" indicator is set and the function returns ``-1`` immediately (such that "
"other pending signals may not have been handled yet: they will be on the "
"next :c:func:`PyErr_CheckSignals()` invocation)."
msgstr ""

#: ../../c-api/exceptions.rst:521
msgid ""
"If the function is called from a non-main thread, or under a non-main "
"Python interpreter, it does nothing and returns ``0``."
msgstr ""

#: ../../c-api/exceptions.rst:524
msgid ""
"This function can be called by long-running C code that wants to be "
"interruptible by user requests (such as by pressing Ctrl-C)."
msgstr ""

#: ../../c-api/exceptions.rst:528
msgid ""
"The default Python signal handler for :const:`SIGINT` raises the "
":exc:`KeyboardInterrupt` exception."
msgstr ""

#: ../../c-api/exceptions.rst:539
msgid ""
"Simulate the effect of a :const:`SIGINT` signal arriving. This is "
"equivalent to ``PyErr_SetInterruptEx(SIGINT)``."
msgstr ""

#: ../../c-api/exceptions.rst:543 ../../c-api/exceptions.rst:570
msgid ""
"This function is async-signal-safe.  It can be called without the "
":term:`GIL` and from a C signal handler."
msgstr ""

#: ../../c-api/exceptions.rst:553
msgid ""
"Simulate the effect of a signal arriving. The next time "
":c:func:`PyErr_CheckSignals` is called,  the Python signal handler for "
"the given signal number will be called."
msgstr ""

#: ../../c-api/exceptions.rst:557
msgid ""
"This function can be called by C code that sets up its own signal "
"handling and wants Python signal handlers to be invoked as expected when "
"an interruption is requested (for example when the user presses Ctrl-C to"
" interrupt an operation)."
msgstr ""

#: ../../c-api/exceptions.rst:562
msgid ""
"If the given signal isn't handled by Python (it was set to "
":data:`signal.SIG_DFL` or :data:`signal.SIG_IGN`), it will be ignored."
msgstr ""

#: ../../c-api/exceptions.rst:565
msgid ""
"If *signum* is outside of the allowed range of signal numbers, ``-1`` is "
"returned.  Otherwise, ``0`` is returned.  The error indicator is never "
"changed by this function."
msgstr ""

#: ../../c-api/exceptions.rst:578
msgid ""
"This utility function specifies a file descriptor to which the signal "
"number is written as a single byte whenever a signal is received. *fd* "
"must be non-blocking. It returns the previous such file descriptor."
msgstr ""

#: ../../c-api/exceptions.rst:582
msgid ""
"The value ``-1`` disables the feature; this is the initial state. This is"
" equivalent to :func:`signal.set_wakeup_fd` in Python, but without any "
"error checking.  *fd* should be a valid file descriptor.  The function "
"should only be called from the main thread."
msgstr ""

#: ../../c-api/exceptions.rst:587
msgid "On Windows, the function now also supports socket handles."
msgstr "在 Windows 上，此函数现在也支持套接字处理。"

#: ../../c-api/exceptions.rst:592
msgid "Exception Classes"
msgstr "Exception 类"

#: ../../c-api/exceptions.rst:596
msgid ""
"This utility function creates and returns a new exception class. The "
"*name* argument must be the name of the new exception, a C string of the "
"form ``module.classname``.  The *base* and *dict* arguments are normally "
"``NULL``. This creates a class object derived from :exc:`Exception` "
"(accessible in C as :c:data:`PyExc_Exception`)."
msgstr ""

#: ../../c-api/exceptions.rst:602
msgid ""
"The :attr:`__module__` attribute of the new class is set to the first "
"part (up to the last dot) of the *name* argument, and the class name is "
"set to the last part (after the last dot).  The *base* argument can be "
"used to specify alternate base classes; it can either be only one class "
"or a tuple of classes. The *dict* argument can be used to specify a "
"dictionary of class variables and methods."
msgstr ""

#: ../../c-api/exceptions.rst:611
msgid ""
"Same as :c:func:`PyErr_NewException`, except that the new exception class"
" can easily be given a docstring: If *doc* is non-``NULL``, it will be "
"used as the docstring for the exception class."
msgstr ""
"和 :c:func:`PyErr_NewException` 一样，除了可以轻松地给新的异常类一个文档字符串：如果 *doc* "
"属性非空，它将用作异常类的文档字符串。"

#: ../../c-api/exceptions.rst:619
msgid "Exception Objects"
msgstr "异常对象"

#: ../../c-api/exceptions.rst:623
msgid ""
"Return the traceback associated with the exception as a new reference, as"
" accessible from Python through :attr:`__traceback__`.  If there is no "
"traceback associated, this returns ``NULL``."
msgstr ""

#: ../../c-api/exceptions.rst:630
msgid ""
"Set the traceback associated with the exception to *tb*.  Use ``Py_None``"
" to clear it."
msgstr "将异常关联的回溯设置为 *tb* 。使用``Py_None``清除它。"

#: ../../c-api/exceptions.rst:636
msgid ""
"Return the context (another exception instance during whose handling *ex*"
" was raised) associated with the exception as a new reference, as "
"accessible from Python through :attr:`__context__`.  If there is no "
"context associated, this returns ``NULL``."
msgstr ""

#: ../../c-api/exceptions.rst:644
msgid ""
"Set the context associated with the exception to *ctx*.  Use ``NULL`` to "
"clear it.  There is no type check to make sure that *ctx* is an exception"
" instance. This steals a reference to *ctx*."
msgstr ""

#: ../../c-api/exceptions.rst:651
msgid ""
"Return the cause (either an exception instance, or :const:`None`, set by "
"``raise ... from ...``) associated with the exception as a new reference,"
" as accessible from Python through :attr:`__cause__`."
msgstr ""

#: ../../c-api/exceptions.rst:658
msgid ""
"Set the cause associated with the exception to *cause*.  Use ``NULL`` to "
"clear it.  There is no type check to make sure that *cause* is either an "
"exception instance or :const:`None`.  This steals a reference to *cause*."
msgstr ""

#: ../../c-api/exceptions.rst:662
msgid ""
":attr:`__suppress_context__` is implicitly set to ``True`` by this "
"function."
msgstr ""

#: ../../c-api/exceptions.rst:668
msgid "Unicode Exception Objects"
msgstr "Unicode 异常对象"

#: ../../c-api/exceptions.rst:670
msgid ""
"The following functions are used to create and modify Unicode exceptions "
"from C."
msgstr ""

#: ../../c-api/exceptions.rst:674
msgid ""
"Create a :class:`UnicodeDecodeError` object with the attributes "
"*encoding*, *object*, *length*, *start*, *end* and *reason*. *encoding* "
"and *reason* are UTF-8 encoded strings."
msgstr ""

#: ../../c-api/exceptions.rst:680
msgid ""
"Create a :class:`UnicodeEncodeError` object with the attributes "
"*encoding*, *object*, *length*, *start*, *end* and *reason*. *encoding* "
"and *reason* are UTF-8 encoded strings."
msgstr ""

#: ../../c-api/exceptions.rst:684 ../../c-api/exceptions.rst:694
msgid "3.11"
msgstr "3.11"

#: ../../c-api/exceptions.rst:686
msgid ""
"``Py_UNICODE`` is deprecated since Python 3.3. Please migrate to "
"``PyObject_CallFunction(PyExc_UnicodeEncodeError, \"sOnns\", ...)``."
msgstr ""

#: ../../c-api/exceptions.rst:691
msgid ""
"Create a :class:`UnicodeTranslateError` object with the attributes "
"*object*, *length*, *start*, *end* and *reason*. *reason* is a UTF-8 "
"encoded string."
msgstr ""

#: ../../c-api/exceptions.rst:696
msgid ""
"``Py_UNICODE`` is deprecated since Python 3.3. Please migrate to "
"``PyObject_CallFunction(PyExc_UnicodeTranslateError, \"Onns\", ...)``."
msgstr ""

#: ../../c-api/exceptions.rst:702
msgid "Return the *encoding* attribute of the given exception object."
msgstr "返回给定异常对象的 *encoding* 属性"

#: ../../c-api/exceptions.rst:708
msgid "Return the *object* attribute of the given exception object."
msgstr "返回给定异常对象的 *object* 属性"

#: ../../c-api/exceptions.rst:714
msgid ""
"Get the *start* attribute of the given exception object and place it into"
" *\\*start*.  *start* must not be ``NULL``.  Return ``0`` on success, "
"``-1`` on failure."
msgstr ""

#: ../../c-api/exceptions.rst:722
msgid ""
"Set the *start* attribute of the given exception object to *start*.  "
"Return ``0`` on success, ``-1`` on failure."
msgstr ""

#: ../../c-api/exceptions.rst:729
msgid ""
"Get the *end* attribute of the given exception object and place it into "
"*\\*end*.  *end* must not be ``NULL``.  Return ``0`` on success, ``-1`` "
"on failure."
msgstr ""

#: ../../c-api/exceptions.rst:737
msgid ""
"Set the *end* attribute of the given exception object to *end*.  Return "
"``0`` on success, ``-1`` on failure."
msgstr ""

#: ../../c-api/exceptions.rst:744
msgid "Return the *reason* attribute of the given exception object."
msgstr "返回给定异常对象的 *reason* 属性"

#: ../../c-api/exceptions.rst:750
msgid ""
"Set the *reason* attribute of the given exception object to *reason*.  "
"Return ``0`` on success, ``-1`` on failure."
msgstr ""

#: ../../c-api/exceptions.rst:757
msgid "Recursion Control"
msgstr "递归控制"

#: ../../c-api/exceptions.rst:759
msgid ""
"These two functions provide a way to perform safe recursive calls at the "
"C level, both in the core and in extension modules.  They are needed if "
"the recursive code does not necessarily invoke Python code (which tracks "
"its recursion depth automatically). They are also not needed for "
"*tp_call* implementations because the :ref:`call protocol <call>` takes "
"care of recursion handling."
msgstr ""

#: ../../c-api/exceptions.rst:768
msgid "Marks a point where a recursive C-level call is about to be performed."
msgstr ""

#: ../../c-api/exceptions.rst:770
msgid ""
"If :const:`USE_STACKCHECK` is defined, this function checks if the OS "
"stack overflowed using :c:func:`PyOS_CheckStack`.  In this is the case, "
"it sets a :exc:`MemoryError` and returns a nonzero value."
msgstr ""

#: ../../c-api/exceptions.rst:774
msgid ""
"The function then checks if the recursion limit is reached.  If this is "
"the case, a :exc:`RecursionError` is set and a nonzero value is returned."
" Otherwise, zero is returned."
msgstr ""

#: ../../c-api/exceptions.rst:778
msgid ""
"*where* should be a UTF-8 encoded string such as ``\" in instance "
"check\"`` to be concatenated to the :exc:`RecursionError` message caused "
"by the recursion depth limit."
msgstr ""

#: ../../c-api/exceptions.rst:782 ../../c-api/exceptions.rst:790
msgid "This function is now also available in the limited API."
msgstr ""

#: ../../c-api/exceptions.rst:787
msgid ""
"Ends a :c:func:`Py_EnterRecursiveCall`.  Must be called once for each "
"*successful* invocation of :c:func:`Py_EnterRecursiveCall`."
msgstr ""

#: ../../c-api/exceptions.rst:793
msgid ""
"Properly implementing :c:member:`~PyTypeObject.tp_repr` for container "
"types requires special recursion handling.  In addition to protecting the"
" stack, :c:member:`~PyTypeObject.tp_repr` also needs to track objects to "
"prevent cycles.  The following two functions facilitate this "
"functionality.  Effectively, these are the C equivalent to "
":func:`reprlib.recursive_repr`."
msgstr ""

#: ../../c-api/exceptions.rst:801
msgid ""
"Called at the beginning of the :c:member:`~PyTypeObject.tp_repr` "
"implementation to detect cycles."
msgstr ""

#: ../../c-api/exceptions.rst:804
msgid ""
"If the object has already been processed, the function returns a positive"
" integer.  In that case the :c:member:`~PyTypeObject.tp_repr` "
"implementation should return a string object indicating a cycle.  As "
"examples, :class:`dict` objects return ``{...}`` and :class:`list` "
"objects return ``[...]``."
msgstr ""

#: ../../c-api/exceptions.rst:810
msgid ""
"The function will return a negative integer if the recursion limit is "
"reached.  In that case the :c:member:`~PyTypeObject.tp_repr` "
"implementation should typically return ``NULL``."
msgstr ""

#: ../../c-api/exceptions.rst:814
msgid ""
"Otherwise, the function returns zero and the "
":c:member:`~PyTypeObject.tp_repr` implementation can continue normally."
msgstr ""

#: ../../c-api/exceptions.rst:819
msgid ""
"Ends a :c:func:`Py_ReprEnter`.  Must be called once for each invocation "
"of :c:func:`Py_ReprEnter` that returns zero."
msgstr ""

#: ../../c-api/exceptions.rst:826
msgid "Standard Exceptions"
msgstr "标准异常"

#: ../../c-api/exceptions.rst:828
msgid ""
"All standard Python exceptions are available as global variables whose "
"names are ``PyExc_`` followed by the Python exception name.  These have "
"the type :c:type:`PyObject*`; they are all class objects.  For "
"completeness, here are all the variables:"
msgstr ""

#: ../../c-api/exceptions.rst:889 ../../c-api/exceptions.rst:1022
#: ../../c-api/exceptions.rst:1067
msgid "C Name"
msgstr "C 名称"

#: ../../c-api/exceptions.rst:889 ../../c-api/exceptions.rst:1067
msgid "Python Name"
msgstr "Python 名称"

#: ../../c-api/exceptions.rst:889 ../../c-api/exceptions.rst:1022
#: ../../c-api/exceptions.rst:1067
msgid "Notes"
msgstr "备注"

#: ../../c-api/exceptions.rst:891
msgid ":c:data:`PyExc_BaseException`"
msgstr ":c:data:`PyExc_BaseException`"

#: ../../c-api/exceptions.rst:891
msgid ":exc:`BaseException`"
msgstr ":exc:`BaseException`"

#: ../../c-api/exceptions.rst:891 ../../c-api/exceptions.rst:893
#: ../../c-api/exceptions.rst:895 ../../c-api/exceptions.rst:941
#: ../../c-api/exceptions.rst:953 ../../c-api/exceptions.rst:1069
msgid "\\(1)"
msgstr "\\(1)"

#: ../../c-api/exceptions.rst:893
msgid ":c:data:`PyExc_Exception`"
msgstr ":c:data:`PyExc_Exception`"

#: ../../c-api/exceptions.rst:893
msgid ":exc:`Exception`"
msgstr ":exc:`Exception`"

#: ../../c-api/exceptions.rst:895
msgid ":c:data:`PyExc_ArithmeticError`"
msgstr ":c:data:`PyExc_ArithmeticError`"

#: ../../c-api/exceptions.rst:895
msgid ":exc:`ArithmeticError`"
msgstr ":exc:`ArithmeticError`"

#: ../../c-api/exceptions.rst:897
msgid ":c:data:`PyExc_AssertionError`"
msgstr ":c:data:`PyExc_AssertionError`"

#: ../../c-api/exceptions.rst:897
msgid ":exc:`AssertionError`"
msgstr ":exc:`AssertionError`"

#: ../../c-api/exceptions.rst:899
msgid ":c:data:`PyExc_AttributeError`"
msgstr ":c:data:`PyExc_AttributeError`"

#: ../../c-api/exceptions.rst:899
msgid ":exc:`AttributeError`"
msgstr ":exc:`AttributeError`"

#: ../../c-api/exceptions.rst:901
msgid ":c:data:`PyExc_BlockingIOError`"
msgstr ":c:data:`PyExc_BlockingIOError`"

#: ../../c-api/exceptions.rst:901
msgid ":exc:`BlockingIOError`"
msgstr ":exc:`BlockingIOError`"

#: ../../c-api/exceptions.rst:903
msgid ":c:data:`PyExc_BrokenPipeError`"
msgstr ":c:data:`PyExc_BrokenPipeError`"

#: ../../c-api/exceptions.rst:903
msgid ":exc:`BrokenPipeError`"
msgstr ":exc:`BrokenPipeError`"

#: ../../c-api/exceptions.rst:905
msgid ":c:data:`PyExc_BufferError`"
msgstr ":c:data:`PyExc_BufferError`"

#: ../../c-api/exceptions.rst:905
msgid ":exc:`BufferError`"
msgstr ":exc:`BufferError`"

#: ../../c-api/exceptions.rst:907
msgid ":c:data:`PyExc_ChildProcessError`"
msgstr ":c:data:`PyExc_ChildProcessError`"

#: ../../c-api/exceptions.rst:907
msgid ":exc:`ChildProcessError`"
msgstr ":exc:`ChildProcessError`"

#: ../../c-api/exceptions.rst:909
msgid ":c:data:`PyExc_ConnectionAbortedError`"
msgstr ":c:data:`PyExc_ConnectionAbortedError`"

#: ../../c-api/exceptions.rst:909
msgid ":exc:`ConnectionAbortedError`"
msgstr ":exc:`ConnectionAbortedError`"

#: ../../c-api/exceptions.rst:911
msgid ":c:data:`PyExc_ConnectionError`"
msgstr ":c:data:`PyExc_ConnectionError`"

#: ../../c-api/exceptions.rst:911
msgid ":exc:`ConnectionError`"
msgstr ":exc:`ConnectionError`"

#: ../../c-api/exceptions.rst:913
msgid ":c:data:`PyExc_ConnectionRefusedError`"
msgstr ":c:data:`PyExc_ConnectionRefusedError`"

#: ../../c-api/exceptions.rst:913
msgid ":exc:`ConnectionRefusedError`"
msgstr ":exc:`ConnectionRefusedError`"

#: ../../c-api/exceptions.rst:915
msgid ":c:data:`PyExc_ConnectionResetError`"
msgstr ":c:data:`PyExc_ConnectionResetError`"

#: ../../c-api/exceptions.rst:915
msgid ":exc:`ConnectionResetError`"
msgstr ":exc:`ConnectionResetError`"

#: ../../c-api/exceptions.rst:917
msgid ":c:data:`PyExc_EOFError`"
msgstr ":c:data:`PyExc_EOFError`"

#: ../../c-api/exceptions.rst:917
msgid ":exc:`EOFError`"
msgstr ":exc:`EOFError`"

#: ../../c-api/exceptions.rst:919
msgid ":c:data:`PyExc_FileExistsError`"
msgstr ":c:data:`PyExc_FileExistsError`"

#: ../../c-api/exceptions.rst:919
msgid ":exc:`FileExistsError`"
msgstr ":exc:`FileExistsError`"

#: ../../c-api/exceptions.rst:921
msgid ":c:data:`PyExc_FileNotFoundError`"
msgstr ":c:data:`PyExc_FileNotFoundError`"

#: ../../c-api/exceptions.rst:921
msgid ":exc:`FileNotFoundError`"
msgstr ":exc:`FileNotFoundError`"

#: ../../c-api/exceptions.rst:923
msgid ":c:data:`PyExc_FloatingPointError`"
msgstr ":c:data:`PyExc_FloatingPointError`"

#: ../../c-api/exceptions.rst:923
msgid ":exc:`FloatingPointError`"
msgstr ":exc:`FloatingPointError`"

#: ../../c-api/exceptions.rst:925
msgid ":c:data:`PyExc_GeneratorExit`"
msgstr ":c:data:`PyExc_GeneratorExit`"

#: ../../c-api/exceptions.rst:925
msgid ":exc:`GeneratorExit`"
msgstr ":exc:`GeneratorExit`"

#: ../../c-api/exceptions.rst:927
msgid ":c:data:`PyExc_ImportError`"
msgstr ":c:data:`PyExc_ImportError`"

#: ../../c-api/exceptions.rst:927
msgid ":exc:`ImportError`"
msgstr ":exc:`ImportError`"

#: ../../c-api/exceptions.rst:929
msgid ":c:data:`PyExc_IndentationError`"
msgstr ":c:data:`PyExc_IndentationError`"

#: ../../c-api/exceptions.rst:929
msgid ":exc:`IndentationError`"
msgstr ":exc:`IndentationError`"

#: ../../c-api/exceptions.rst:931
msgid ":c:data:`PyExc_IndexError`"
msgstr ":c:data:`PyExc_IndexError`"

#: ../../c-api/exceptions.rst:931
msgid ":exc:`IndexError`"
msgstr ":exc:`IndexError`"

#: ../../c-api/exceptions.rst:933
msgid ":c:data:`PyExc_InterruptedError`"
msgstr ":c:data:`PyExc_InterruptedError`"

#: ../../c-api/exceptions.rst:933
msgid ":exc:`InterruptedError`"
msgstr ":exc:`InterruptedError`"

#: ../../c-api/exceptions.rst:935
msgid ":c:data:`PyExc_IsADirectoryError`"
msgstr ":c:data:`PyExc_IsADirectoryError`"

#: ../../c-api/exceptions.rst:935
msgid ":exc:`IsADirectoryError`"
msgstr ":exc:`IsADirectoryError`"

#: ../../c-api/exceptions.rst:937
msgid ":c:data:`PyExc_KeyError`"
msgstr ":c:data:`PyExc_KeyError`"

#: ../../c-api/exceptions.rst:937
msgid ":exc:`KeyError`"
msgstr ":exc:`KeyError`"

#: ../../c-api/exceptions.rst:939
msgid ":c:data:`PyExc_KeyboardInterrupt`"
msgstr ":c:data:`PyExc_KeyboardInterrupt`"

#: ../../c-api/exceptions.rst:939
msgid ":exc:`KeyboardInterrupt`"
msgstr ":exc:`KeyboardInterrupt`"

#: ../../c-api/exceptions.rst:941
msgid ":c:data:`PyExc_LookupError`"
msgstr ":c:data:`PyExc_LookupError`"

#: ../../c-api/exceptions.rst:941
msgid ":exc:`LookupError`"
msgstr ":exc:`LookupError`"

#: ../../c-api/exceptions.rst:943
msgid ":c:data:`PyExc_MemoryError`"
msgstr ":c:data:`PyExc_MemoryError`"

#: ../../c-api/exceptions.rst:943
msgid ":exc:`MemoryError`"
msgstr ":exc:`MemoryError`"

#: ../../c-api/exceptions.rst:945
msgid ":c:data:`PyExc_ModuleNotFoundError`"
msgstr ":c:data:`PyExc_ModuleNotFoundError`"

#: ../../c-api/exceptions.rst:945
msgid ":exc:`ModuleNotFoundError`"
msgstr ":exc:`ModuleNotFoundError`"

#: ../../c-api/exceptions.rst:947
msgid ":c:data:`PyExc_NameError`"
msgstr ":c:data:`PyExc_NameError`"

#: ../../c-api/exceptions.rst:947
msgid ":exc:`NameError`"
msgstr ":exc:`NameError`"

#: ../../c-api/exceptions.rst:949
msgid ":c:data:`PyExc_NotADirectoryError`"
msgstr ":c:data:`PyExc_NotADirectoryError`"

#: ../../c-api/exceptions.rst:949
msgid ":exc:`NotADirectoryError`"
msgstr ":exc:`NotADirectoryError`"

#: ../../c-api/exceptions.rst:951
msgid ":c:data:`PyExc_NotImplementedError`"
msgstr ":c:data:`PyExc_NotImplementedError`"

#: ../../c-api/exceptions.rst:951
msgid ":exc:`NotImplementedError`"
msgstr ":exc:`NotImplementedError`"

#: ../../c-api/exceptions.rst:953
msgid ":c:data:`PyExc_OSError`"
msgstr ":c:data:`PyExc_OSError`"

#: ../../c-api/exceptions.rst:953
msgid ":exc:`OSError`"
msgstr ":exc:`OSError`"

#: ../../c-api/exceptions.rst:955
msgid ":c:data:`PyExc_OverflowError`"
msgstr ":c:data:`PyExc_OverflowError`"

#: ../../c-api/exceptions.rst:955
msgid ":exc:`OverflowError`"
msgstr ":exc:`OverflowError`"

#: ../../c-api/exceptions.rst:957
msgid ":c:data:`PyExc_PermissionError`"
msgstr ":c:data:`PyExc_PermissionError`"

#: ../../c-api/exceptions.rst:957
msgid ":exc:`PermissionError`"
msgstr ":exc:`PermissionError`"

#: ../../c-api/exceptions.rst:959
msgid ":c:data:`PyExc_ProcessLookupError`"
msgstr ":c:data:`PyExc_ProcessLookupError`"

#: ../../c-api/exceptions.rst:959
msgid ":exc:`ProcessLookupError`"
msgstr ":exc:`ProcessLookupError`"

#: ../../c-api/exceptions.rst:961
msgid ":c:data:`PyExc_RecursionError`"
msgstr ":c:data:`PyExc_RecursionError`"

#: ../../c-api/exceptions.rst:961
msgid ":exc:`RecursionError`"
msgstr ":exc:`RecursionError`"

#: ../../c-api/exceptions.rst:963
msgid ":c:data:`PyExc_ReferenceError`"
msgstr ":c:data:`PyExc_ReferenceError`"

#: ../../c-api/exceptions.rst:963
msgid ":exc:`ReferenceError`"
msgstr ":exc:`ReferenceError`"

#: ../../c-api/exceptions.rst:963
msgid "\\(2)"
msgstr "\\(2)"

#: ../../c-api/exceptions.rst:965
msgid ":c:data:`PyExc_RuntimeError`"
msgstr ":c:data:`PyExc_RuntimeError`"

#: ../../c-api/exceptions.rst:965
msgid ":exc:`RuntimeError`"
msgstr ":exc:`RuntimeError`"

#: ../../c-api/exceptions.rst:967
msgid ":c:data:`PyExc_StopAsyncIteration`"
msgstr ":c:data:`PyExc_StopAsyncIteration`"

#: ../../c-api/exceptions.rst:967
msgid ":exc:`StopAsyncIteration`"
msgstr ":exc:`StopAsyncIteration`"

#: ../../c-api/exceptions.rst:969
msgid ":c:data:`PyExc_StopIteration`"
msgstr ":c:data:`PyExc_StopIteration`"

#: ../../c-api/exceptions.rst:969
msgid ":exc:`StopIteration`"
msgstr ":exc:`StopIteration`"

#: ../../c-api/exceptions.rst:971
msgid ":c:data:`PyExc_SyntaxError`"
msgstr ":c:data:`PyExc_SyntaxError`"

#: ../../c-api/exceptions.rst:971
msgid ":exc:`SyntaxError`"
msgstr ":exc:`SyntaxError`"

#: ../../c-api/exceptions.rst:973
msgid ":c:data:`PyExc_SystemError`"
msgstr ":c:data:`PyExc_SystemError`"

#: ../../c-api/exceptions.rst:973
msgid ":exc:`SystemError`"
msgstr ":exc:`SystemError`"

#: ../../c-api/exceptions.rst:975
msgid ":c:data:`PyExc_SystemExit`"
msgstr ":c:data:`PyExc_SystemExit`"

#: ../../c-api/exceptions.rst:975
msgid ":exc:`SystemExit`"
msgstr ":exc:`SystemExit`"

#: ../../c-api/exceptions.rst:977
msgid ":c:data:`PyExc_TabError`"
msgstr ":c:data:`PyExc_TabError`"

#: ../../c-api/exceptions.rst:977
msgid ":exc:`TabError`"
msgstr ":exc:`TabError`"

#: ../../c-api/exceptions.rst:979
msgid ":c:data:`PyExc_TimeoutError`"
msgstr ":c:data:`PyExc_TimeoutError`"

#: ../../c-api/exceptions.rst:979
msgid ":exc:`TimeoutError`"
msgstr ":exc:`TimeoutError`"

#: ../../c-api/exceptions.rst:981
msgid ":c:data:`PyExc_TypeError`"
msgstr ":c:data:`PyExc_TypeError`"

#: ../../c-api/exceptions.rst:981
msgid ":exc:`TypeError`"
msgstr ":exc:`TypeError`"

#: ../../c-api/exceptions.rst:983
msgid ":c:data:`PyExc_UnboundLocalError`"
msgstr ":c:data:`PyExc_UnboundLocalError`"

#: ../../c-api/exceptions.rst:983
msgid ":exc:`UnboundLocalError`"
msgstr ":exc:`UnboundLocalError`"

#: ../../c-api/exceptions.rst:985
msgid ":c:data:`PyExc_UnicodeDecodeError`"
msgstr ":c:data:`PyExc_UnicodeDecodeError`"

#: ../../c-api/exceptions.rst:985
msgid ":exc:`UnicodeDecodeError`"
msgstr ":exc:`UnicodeDecodeError`"

#: ../../c-api/exceptions.rst:987
msgid ":c:data:`PyExc_UnicodeEncodeError`"
msgstr ":c:data:`PyExc_UnicodeEncodeError`"

#: ../../c-api/exceptions.rst:987
msgid ":exc:`UnicodeEncodeError`"
msgstr ":exc:`UnicodeEncodeError`"

#: ../../c-api/exceptions.rst:989
msgid ":c:data:`PyExc_UnicodeError`"
msgstr ":c:data:`PyExc_UnicodeError`"

#: ../../c-api/exceptions.rst:989
msgid ":exc:`UnicodeError`"
msgstr ":exc:`UnicodeError`"

#: ../../c-api/exceptions.rst:991
msgid ":c:data:`PyExc_UnicodeTranslateError`"
msgstr ":c:data:`PyExc_UnicodeTranslateError`"

#: ../../c-api/exceptions.rst:991
msgid ":exc:`UnicodeTranslateError`"
msgstr ":exc:`UnicodeTranslateError`"

#: ../../c-api/exceptions.rst:993
msgid ":c:data:`PyExc_ValueError`"
msgstr ":c:data:`PyExc_ValueError`"

#: ../../c-api/exceptions.rst:993
msgid ":exc:`ValueError`"
msgstr ":exc:`ValueError`"

#: ../../c-api/exceptions.rst:995
msgid ":c:data:`PyExc_ZeroDivisionError`"
msgstr ":c:data:`PyExc_ZeroDivisionError`"

#: ../../c-api/exceptions.rst:995
msgid ":exc:`ZeroDivisionError`"
msgstr ":exc:`ZeroDivisionError`"

#: ../../c-api/exceptions.rst:998
msgid ""
":c:data:`PyExc_BlockingIOError`, :c:data:`PyExc_BrokenPipeError`, "
":c:data:`PyExc_ChildProcessError`, :c:data:`PyExc_ConnectionError`, "
":c:data:`PyExc_ConnectionAbortedError`, "
":c:data:`PyExc_ConnectionRefusedError`, "
":c:data:`PyExc_ConnectionResetError`, :c:data:`PyExc_FileExistsError`, "
":c:data:`PyExc_FileNotFoundError`, :c:data:`PyExc_InterruptedError`, "
":c:data:`PyExc_IsADirectoryError`, :c:data:`PyExc_NotADirectoryError`, "
":c:data:`PyExc_PermissionError`, :c:data:`PyExc_ProcessLookupError` and "
":c:data:`PyExc_TimeoutError` were introduced following :pep:`3151`."
msgstr ""
":c:data:`PyExc_BlockingIOError`, :c:data:`PyExc_BrokenPipeError`, "
":c:data:`PyExc_ChildProcessError`, :c:data:`PyExc_ConnectionError`, "
":c:data:`PyExc_ConnectionAbortedError`, "
":c:data:`PyExc_ConnectionRefusedError`, "
":c:data:`PyExc_ConnectionResetError`, :c:data:`PyExc_FileExistsError`, "
":c:data:`PyExc_FileNotFoundError`, :c:data:`PyExc_InterruptedError`, "
":c:data:`PyExc_IsADirectoryError`, :c:data:`PyExc_NotADirectoryError`, "
":c:data:`PyExc_PermissionError`, :c:data:`PyExc_ProcessLookupError` and "
":c:data:`PyExc_TimeoutError` 介绍如下 :pep:`3151`."

#: ../../c-api/exceptions.rst:1008
msgid ":c:data:`PyExc_StopAsyncIteration` and :c:data:`PyExc_RecursionError`."
msgstr ":c:data:`PyExc_StopAsyncIteration` 和 :c:data:`PyExc_RecursionError`."

#: ../../c-api/exceptions.rst:1011
msgid ":c:data:`PyExc_ModuleNotFoundError`."
msgstr ":c:data:`PyExc_ModuleNotFoundError`."

#: ../../c-api/exceptions.rst:1014
msgid "These are compatibility aliases to :c:data:`PyExc_OSError`:"
msgstr "这些是兼容性别名 :c:data:`PyExc_OSError`:"

#: ../../c-api/exceptions.rst:1024
msgid ":c:data:`PyExc_EnvironmentError`"
msgstr ":c:data:`PyExc_EnvironmentError`"

#: ../../c-api/exceptions.rst:1026
msgid ":c:data:`PyExc_IOError`"
msgstr ":c:data:`PyExc_IOError`"

#: ../../c-api/exceptions.rst:1028
msgid ":c:data:`PyExc_WindowsError`"
msgstr ":c:data:`PyExc_WindowsError`"

#: ../../c-api/exceptions.rst:1028
msgid "\\(3)"
msgstr "\\(3)"

#: ../../c-api/exceptions.rst:1031
msgid "These aliases used to be separate exception types."
msgstr "这些别名曾经是单独的异常类型。"

#: ../../c-api/exceptions.rst:1034 ../../c-api/exceptions.rst:1095
msgid "Notes:"
msgstr "注释："

#: ../../c-api/exceptions.rst:1037
msgid "This is a base class for other standard exceptions."
msgstr "这是其他标准异常的基类。"

#: ../../c-api/exceptions.rst:1040
msgid ""
"Only defined on Windows; protect code that uses this by testing that the "
"preprocessor macro ``MS_WINDOWS`` is defined."
msgstr ""

#: ../../c-api/exceptions.rst:1046
msgid "Standard Warning Categories"
msgstr "标准警告类别"

#: ../../c-api/exceptions.rst:1048
msgid ""
"All standard Python warning categories are available as global variables "
"whose names are ``PyExc_`` followed by the Python exception name. These "
"have the type :c:type:`PyObject*`; they are all class objects. For "
"completeness, here are all the variables:"
msgstr ""

#: ../../c-api/exceptions.rst:1069
msgid ":c:data:`PyExc_Warning`"
msgstr ":c:data:`PyExc_Warning`"

#: ../../c-api/exceptions.rst:1069
msgid ":exc:`Warning`"
msgstr ":exc:`Warning`"

#: ../../c-api/exceptions.rst:1071
msgid ":c:data:`PyExc_BytesWarning`"
msgstr ":c:data:`PyExc_BytesWarning`"

#: ../../c-api/exceptions.rst:1071
msgid ":exc:`BytesWarning`"
msgstr ":exc:`BytesWarning`"

#: ../../c-api/exceptions.rst:1073
msgid ":c:data:`PyExc_DeprecationWarning`"
msgstr ":c:data:`PyExc_DeprecationWarning`"

#: ../../c-api/exceptions.rst:1073
msgid ":exc:`DeprecationWarning`"
msgstr ":exc:`DeprecationWarning`"

#: ../../c-api/exceptions.rst:1075
msgid ":c:data:`PyExc_FutureWarning`"
msgstr ":c:data:`PyExc_FutureWarning`"

#: ../../c-api/exceptions.rst:1075
msgid ":exc:`FutureWarning`"
msgstr ":exc:`FutureWarning`"

#: ../../c-api/exceptions.rst:1077
msgid ":c:data:`PyExc_ImportWarning`"
msgstr ":c:data:`PyExc_ImportWarning`"

#: ../../c-api/exceptions.rst:1077
msgid ":exc:`ImportWarning`"
msgstr ":exc:`ImportWarning`"

#: ../../c-api/exceptions.rst:1079
msgid ":c:data:`PyExc_PendingDeprecationWarning`"
msgstr ":c:data:`PyExc_PendingDeprecationWarning`"

#: ../../c-api/exceptions.rst:1079
msgid ":exc:`PendingDeprecationWarning`"
msgstr ":exc:`PendingDeprecationWarning`"

#: ../../c-api/exceptions.rst:1081
msgid ":c:data:`PyExc_ResourceWarning`"
msgstr ":c:data:`PyExc_ResourceWarning`"

#: ../../c-api/exceptions.rst:1081
msgid ":exc:`ResourceWarning`"
msgstr ":exc:`ResourceWarning`"

#: ../../c-api/exceptions.rst:1083
msgid ":c:data:`PyExc_RuntimeWarning`"
msgstr ":c:data:`PyExc_RuntimeWarning`"

#: ../../c-api/exceptions.rst:1083
msgid ":exc:`RuntimeWarning`"
msgstr ":exc:`RuntimeWarning`"

#: ../../c-api/exceptions.rst:1085
msgid ":c:data:`PyExc_SyntaxWarning`"
msgstr ":c:data:`PyExc_SyntaxWarning`"

#: ../../c-api/exceptions.rst:1085
msgid ":exc:`SyntaxWarning`"
msgstr ":exc:`SyntaxWarning`"

#: ../../c-api/exceptions.rst:1087
msgid ":c:data:`PyExc_UnicodeWarning`"
msgstr ":c:data:`PyExc_UnicodeWarning`"

#: ../../c-api/exceptions.rst:1087
msgid ":exc:`UnicodeWarning`"
msgstr ":exc:`UnicodeWarning`"

#: ../../c-api/exceptions.rst:1089
msgid ":c:data:`PyExc_UserWarning`"
msgstr ":c:data:`PyExc_UserWarning`"

#: ../../c-api/exceptions.rst:1089
msgid ":exc:`UserWarning`"
msgstr ":exc:`UserWarning`"

#: ../../c-api/exceptions.rst:1092
msgid ":c:data:`PyExc_ResourceWarning`."
msgstr ":c:data:`PyExc_ResourceWarning`."

#: ../../c-api/exceptions.rst:1098
msgid "This is a base class for other standard warning categories."
msgstr "这是其他标准警告类别的基类。"

