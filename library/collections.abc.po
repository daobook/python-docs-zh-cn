# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
# Translators:
# Woko <banbooliu@gmail.com>, 2021
# Freesand Leo <yuqinju@163.com>, 2021
# Jarry Shaw <jarryshaw@icloud.com>, 2021
# walkinrain <walkinrain2008@outlook.com>, 2021
# ppcfish <ppcfish@gmail.com>, 2021
# Hissy <aozora@live.cn>, 2021
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-21 14:44+0800\n"
"PO-Revision-Date: 2021-06-28 00:56+0000\n"
"Last-Translator: Hissy <aozora@live.cn>, 2021\n"
"Language: zh_CN\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-"
"doc/teams/5390/zh_CN/)\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../library/collections.abc.rst:2
msgid ":mod:`collections.abc` --- Abstract Base Classes for Containers"
msgstr ":mod:`collections.abc` --- 容器的抽象基类"

#: ../../library/collections.abc.rst:10
msgid "Formerly, this module was part of the :mod:`collections` module."
msgstr "该模块曾是 :mod:`collections` 模块的组成部分。"

#: ../../library/collections.abc.rst:13
msgid "**Source code:** :source:`Lib/_collections_abc.py`"
msgstr "**源代码：** :source:`Lib/_collections_abc.py`"

#: ../../library/collections.abc.rst:23
msgid ""
"This module provides :term:`abstract base classes <abstract base class>` "
"that can be used to test whether a class provides a particular interface;"
" for example, whether it is hashable or whether it is a mapping."
msgstr ""
"该模块定义了一些 :term:`抽象基类 <abstract base "
"class>`，它们可用于判断一个具体类是否具有某一特定的接口；例如，这个类是否可哈希，或其是否为映射类。"

#: ../../library/collections.abc.rst:27
msgid ""
"An :func:`issubclass` or :func:`isinstance` test for an interface works "
"in one of three ways."
msgstr ""

#: ../../library/collections.abc.rst:30
msgid ""
"1) A newly written class can inherit directly from one of the abstract "
"base classes.  The class must supply the required abstract methods.  The "
"remaining mixin methods come from inheritance and can be overridden if "
"desired.  Other methods may be added as needed:"
msgstr ""

#: ../../library/collections.abc.rst:50
msgid ""
"2) Existing classes and built-in classes can be registered as \"virtual "
"subclasses\" of the ABCs.  Those classes should define the full API "
"including all of the abstract methods and all of the mixin methods. This "
"lets users rely on :func:`issubclass` or :func:`isinstance` tests to "
"determine whether the full interface is supported.  The exception to this"
" rule is for methods that are automatically inferred from the rest of the"
" API:"
msgstr ""

#: ../../library/collections.abc.rst:76
msgid ""
"In this example, class :class:`D` does not need to define "
"``__contains__``, ``__iter__``, and ``__reversed__`` because the :ref"
":`in-operator <comparisons>`, the :term:`iteration <iterable>` logic, and"
" the :func:`reversed` function automatically fall back to using "
"``__getitem__`` and ``__len__``."
msgstr ""

#: ../../library/collections.abc.rst:82
msgid ""
"3) Some simple interfaces are directly recognizable by the presence of "
"the required methods (unless those methods have been set to "
":const:`None`):"
msgstr ""

#: ../../library/collections.abc.rst:99
msgid ""
"Complex interfaces do not support this last technique because an "
"interface is more than just the presence of method names.  Interfaces "
"specify semantics and relationships between methods that cannot be "
"inferred solely from the presence of specific method names.  For example,"
" knowing that a class supplies ``__getitem__``, ``__len__``, and "
"``__iter__`` is insufficient for distinguishing a :class:`Sequence` from "
"a :class:`Mapping`."
msgstr ""

#: ../../library/collections.abc.rst:107
msgid ""
"These abstract classes now support ``[]``. See :ref:`types-genericalias` "
"and :pep:`585`."
msgstr ""

#: ../../library/collections.abc.rst:114
msgid "Collections Abstract Base Classes"
msgstr "容器抽象基类"

#: ../../library/collections.abc.rst:116
msgid ""
"The collections module offers the following :term:`ABCs <abstract base "
"class>`:"
msgstr "这个容器模块提供了以下 :term:`ABCs <abstract base class>`:"

#: ../../library/collections.abc.rst:121
msgid "ABC"
msgstr "抽象基类"

#: ../../library/collections.abc.rst:121
msgid "Inherits from"
msgstr "继承自"

#: ../../library/collections.abc.rst:121
msgid "Abstract Methods"
msgstr "抽象方法"

#: ../../library/collections.abc.rst:121
msgid "Mixin Methods"
msgstr "Mixin 方法"

#: ../../library/collections.abc.rst:123
#, fuzzy
msgid ":class:`Container` [1]_"
msgstr ":class:`Container`"

#: ../../library/collections.abc.rst:123
msgid "``__contains__``"
msgstr "``__contains__``"

#: ../../library/collections.abc.rst:124
#, fuzzy
msgid ":class:`Hashable` [1]_"
msgstr ":class:`Hashable`"

#: ../../library/collections.abc.rst:124
msgid "``__hash__``"
msgstr "``__hash__``"

#: ../../library/collections.abc.rst:125
#, fuzzy
msgid ":class:`Iterable` [1]_ [2]_"
msgstr ":class:`Iterable`"

#: ../../library/collections.abc.rst:125 ../../library/collections.abc.rst:126
msgid "``__iter__``"
msgstr "``__iter__``"

#: ../../library/collections.abc.rst:126
#, fuzzy
msgid ":class:`Iterator` [1]_"
msgstr ":class:`Iterator`"

#: ../../library/collections.abc.rst:126 ../../library/collections.abc.rst:127
msgid ":class:`Iterable`"
msgstr ":class:`Iterable`"

#: ../../library/collections.abc.rst:126
msgid "``__next__``"
msgstr "``__next__``"

#: ../../library/collections.abc.rst:127
#, fuzzy
msgid ":class:`Reversible` [1]_"
msgstr ":class:`Reversible`"

#: ../../library/collections.abc.rst:127
msgid "``__reversed__``"
msgstr "``__reversed__``"

#: ../../library/collections.abc.rst:128
#, fuzzy
msgid ":class:`Generator`  [1]_"
msgstr ":class:`Generator`"

#: ../../library/collections.abc.rst:128
msgid ":class:`Iterator`"
msgstr ":class:`Iterator`"

#: ../../library/collections.abc.rst:128 ../../library/collections.abc.rst:176
msgid "``send``, ``throw``"
msgstr "``send``, ``throw``"

#: ../../library/collections.abc.rst:128
msgid "``close``, ``__iter__``, ``__next__``"
msgstr "``close``, ``__iter__``, ``__next__``"

#: ../../library/collections.abc.rst:129
#, fuzzy
msgid ":class:`Sized`  [1]_"
msgstr ":class:`Sized`"

#: ../../library/collections.abc.rst:129 ../../library/collections.abc.rst:168
msgid "``__len__``"
msgstr "``__len__``"

#: ../../library/collections.abc.rst:130
#, fuzzy
msgid ":class:`Callable`  [1]_"
msgstr ":class:`Callable`"

#: ../../library/collections.abc.rst:130
msgid "``__call__``"
msgstr "``__call__``"

#: ../../library/collections.abc.rst:131
#, fuzzy
msgid ":class:`Collection`  [1]_"
msgstr ":class:`Collection`"

#: ../../library/collections.abc.rst:131
msgid ":class:`Sized`, :class:`Iterable`, :class:`Container`"
msgstr ":class:`Sized`, :class:`Iterable`, :class:`Container`"

#: ../../library/collections.abc.rst:131 ../../library/collections.abc.rst:147
msgid "``__contains__``, ``__iter__``, ``__len__``"
msgstr "``__contains__``, ``__iter__``, ``__len__``"

#: ../../library/collections.abc.rst:135 ../../library/collections.abc.rst:138
#: ../../library/collections.abc.rst:144
msgid ":class:`Sequence`"
msgstr ":class:`Sequence`"

#: ../../library/collections.abc.rst:135
msgid ":class:`Reversible`, :class:`Collection`"
msgstr ":class:`Reversible`, :class:`Collection`"

#: ../../library/collections.abc.rst:135 ../../library/collections.abc.rst:144
msgid "``__getitem__``, ``__len__``"
msgstr "``__getitem__``, ``__len__``"

#: ../../library/collections.abc.rst:135
msgid "``__contains__``, ``__iter__``, ``__reversed__``, ``index``, and ``count``"
msgstr "``__contains__``, ``__iter__``, ``__reversed__``, ``index``, and ``count``"

#: ../../library/collections.abc.rst:138
msgid ":class:`MutableSequence`"
msgstr ":class:`MutableSequence`"

#: ../../library/collections.abc.rst:138
msgid "``__getitem__``, ``__setitem__``, ``__delitem__``, ``__len__``, ``insert``"
msgstr "``__getitem__``, ``__setitem__``, ``__delitem__``, ``__len__``, ``insert``"

#: ../../library/collections.abc.rst:138
msgid ""
"Inherited :class:`Sequence` methods and ``append``, ``reverse``, "
"``extend``, ``pop``, ``remove``, and ``__iadd__``"
msgstr ""
"继承自 :class:`Sequence` 的方法，以及 ``append``, ``reverse``, ``extend``, "
"``pop``, ``remove``，和 ``__iadd__``"

#: ../../library/collections.abc.rst:144
msgid ":class:`ByteString`"
msgstr ":class:`ByteString`"

#: ../../library/collections.abc.rst:144
msgid "Inherited :class:`Sequence` methods"
msgstr "继承自 :class:`Sequence` 的方法"

#: ../../library/collections.abc.rst:147 ../../library/collections.abc.rst:151
msgid ":class:`Set`"
msgstr ":class:`Set`"

#: ../../library/collections.abc.rst:147 ../../library/collections.abc.rst:157
msgid ":class:`Collection`"
msgstr ":class:`Collection`"

#: ../../library/collections.abc.rst:147
msgid ""
"``__le__``, ``__lt__``, ``__eq__``, ``__ne__``, ``__gt__``, ``__ge__``, "
"``__and__``, ``__or__``, ``__sub__``, ``__xor__``, and ``isdisjoint``"
msgstr ""
"``__le__``, ``__lt__``, ``__eq__``, ``__ne__``, ``__gt__``, ``__ge__``, "
"``__and__``, ``__or__``, ``__sub__``, ``__xor__``, and ``isdisjoint``"

#: ../../library/collections.abc.rst:151
msgid ":class:`MutableSet`"
msgstr ":class:`MutableSet`"

#: ../../library/collections.abc.rst:151
msgid "``__contains__``, ``__iter__``, ``__len__``, ``add``, ``discard``"
msgstr "``__contains__``, ``__iter__``, ``__len__``, ``add``, ``discard``"

#: ../../library/collections.abc.rst:151
msgid ""
"Inherited :class:`Set` methods and ``clear``, ``pop``, ``remove``, "
"``__ior__``, ``__iand__``, ``__ixor__``, and ``__isub__``"
msgstr ""
"继承自 :class:`Set` 的方法以及 ``clear``, ``pop``, ``remove``, ``__ior__``, "
"``__iand__``, ``__ixor__``，和  ``__isub__``"

#: ../../library/collections.abc.rst:157 ../../library/collections.abc.rst:161
msgid ":class:`Mapping`"
msgstr ":class:`Mapping`"

#: ../../library/collections.abc.rst:157
msgid "``__getitem__``, ``__iter__``, ``__len__``"
msgstr "``__getitem__``, ``__iter__``, ``__len__``"

#: ../../library/collections.abc.rst:157
msgid ""
"``__contains__``, ``keys``, ``items``, ``values``, ``get``, ``__eq__``, "
"and ``__ne__``"
msgstr ""
"``__contains__``, ``keys``, ``items``, ``values``, ``get``, ``__eq__``, "
"and ``__ne__``"

#: ../../library/collections.abc.rst:161
msgid ":class:`MutableMapping`"
msgstr ":class:`MutableMapping`"

#: ../../library/collections.abc.rst:161
msgid ""
"``__getitem__``, ``__setitem__``, ``__delitem__``, ``__iter__``, "
"``__len__``"
msgstr ""
"``__getitem__``, ``__setitem__``, ``__delitem__``, ``__iter__``, "
"``__len__``"

#: ../../library/collections.abc.rst:161
msgid ""
"Inherited :class:`Mapping` methods and ``pop``, ``popitem``, ``clear``, "
"``update``, and ``setdefault``"
msgstr ""
"继承自 :class:`Mapping` 的方法以及 ``pop``, ``popitem``, ``clear``, ``update``，和 "
"``setdefault``"

#: ../../library/collections.abc.rst:168
msgid ":class:`MappingView`"
msgstr ":class:`MappingView`"

#: ../../library/collections.abc.rst:168
msgid ":class:`Sized`"
msgstr ":class:`Sized`"

#: ../../library/collections.abc.rst:169
msgid ":class:`ItemsView`"
msgstr ":class:`ItemsView`"

#: ../../library/collections.abc.rst:169 ../../library/collections.abc.rst:171
msgid ":class:`MappingView`, :class:`Set`"
msgstr ":class:`MappingView`, :class:`Set`"

#: ../../library/collections.abc.rst:169 ../../library/collections.abc.rst:171
#: ../../library/collections.abc.rst:173
msgid "``__contains__``, ``__iter__``"
msgstr "``__contains__``, ``__iter__``"

#: ../../library/collections.abc.rst:171
msgid ":class:`KeysView`"
msgstr ":class:`KeysView`"

#: ../../library/collections.abc.rst:173
msgid ":class:`ValuesView`"
msgstr ":class:`ValuesView`"

#: ../../library/collections.abc.rst:173
msgid ":class:`MappingView`, :class:`Collection`"
msgstr ":class:`MappingView`, :class:`Collection`"

#: ../../library/collections.abc.rst:175
#, fuzzy
msgid ":class:`Awaitable` [1]_"
msgstr ":class:`Awaitable`"

#: ../../library/collections.abc.rst:175
msgid "``__await__``"
msgstr "``__await__``"

#: ../../library/collections.abc.rst:176
#, fuzzy
msgid ":class:`Coroutine` [1]_"
msgstr ":class:`Coroutine`"

#: ../../library/collections.abc.rst:176
msgid ":class:`Awaitable`"
msgstr ":class:`Awaitable`"

#: ../../library/collections.abc.rst:176
msgid "``close``"
msgstr "``close``"

#: ../../library/collections.abc.rst:177
#, fuzzy
msgid ":class:`AsyncIterable` [1]_"
msgstr ":class:`AsyncIterable`"

#: ../../library/collections.abc.rst:177 ../../library/collections.abc.rst:178
msgid "``__aiter__``"
msgstr "``__aiter__``"

#: ../../library/collections.abc.rst:178
#, fuzzy
msgid ":class:`AsyncIterator` [1]_"
msgstr ":class:`AsyncIterator`"

#: ../../library/collections.abc.rst:178
msgid ":class:`AsyncIterable`"
msgstr ":class:`AsyncIterable`"

#: ../../library/collections.abc.rst:178
msgid "``__anext__``"
msgstr "``__anext__``"

#: ../../library/collections.abc.rst:179
#, fuzzy
msgid ":class:`AsyncGenerator` [1]_"
msgstr ":class:`AsyncGenerator`"

#: ../../library/collections.abc.rst:179
msgid ":class:`AsyncIterator`"
msgstr ":class:`AsyncIterator`"

#: ../../library/collections.abc.rst:179
msgid "``asend``, ``athrow``"
msgstr "``asend``, ``athrow``"

#: ../../library/collections.abc.rst:179
msgid "``aclose``, ``__aiter__``, ``__anext__``"
msgstr "``aclose``, ``__aiter__``, ``__anext__``"

#: ../../library/collections.abc.rst:184
msgid "Footnotes"
msgstr ""

#: ../../library/collections.abc.rst:185
msgid ""
"These ABCs override :meth:`object.__subclasshook__` to support testing an"
" interface by verifying the required methods are present and have not "
"been set to :const:`None`.  This only works for simple interfaces.  More "
"complex interfaces require registration or direct subclassing."
msgstr ""

#: ../../library/collections.abc.rst:191
#, fuzzy
msgid ""
"Checking ``isinstance(obj, Iterable)`` detects classes that are "
"registered as :class:`Iterable` or that have an :meth:`__iter__` method, "
"but it does not detect classes that iterate with the :meth:`__getitem__` "
"method.  The only reliable way to determine whether an object is "
":term:`iterable` is to call ``iter(obj)``."
msgstr ""
"使用 ``isinstance(obj, Iterable)`` 可以检测一个类是否已经注册到了 :class:`Iterable` 或者实现了 "
":meth:`__iter__` 函数，但是无法检测这个类是否能够使用 :meth:`__getitem__` 方法进行迭代。检测一个对象是否是 "
":term:`iterable` 的唯一可信赖的方法是调用 ``iter(obj)``。"

#: ../../library/collections.abc.rst:199
#, fuzzy
msgid "Collections Abstract Base Classes -- Detailed Descriptions"
msgstr "容器抽象基类"

#: ../../library/collections.abc.rst:204
msgid "ABC for classes that provide the :meth:`__contains__` method."
msgstr "提供了 :meth:`__contains__` 方法的抽象基类。"

#: ../../library/collections.abc.rst:208
msgid "ABC for classes that provide the :meth:`__hash__` method."
msgstr "提供了 :meth:`__hash__` 方法的抽象基类。"

#: ../../library/collections.abc.rst:212
msgid "ABC for classes that provide the :meth:`__len__` method."
msgstr "提供了 :meth:`__len__` 方法的抽象基类。"

#: ../../library/collections.abc.rst:216
msgid "ABC for classes that provide the :meth:`__call__` method."
msgstr "提供了 :meth:`__call__` 方法的抽象基类。"

#: ../../library/collections.abc.rst:220
msgid "ABC for classes that provide the :meth:`__iter__` method."
msgstr "提供了 :meth:`__iter__` 方法的抽象基类。"

#: ../../library/collections.abc.rst:222
msgid ""
"Checking ``isinstance(obj, Iterable)`` detects classes that are "
"registered as :class:`Iterable` or that have an :meth:`__iter__` method, "
"but it does not detect classes that iterate with the :meth:`__getitem__` "
"method. The only reliable way to determine whether an object is "
":term:`iterable` is to call ``iter(obj)``."
msgstr ""
"使用 ``isinstance(obj, Iterable)`` 可以检测一个类是否已经注册到了 :class:`Iterable` 或者实现了 "
":meth:`__iter__` 函数，但是无法检测这个类是否能够使用 :meth:`__getitem__` 方法进行迭代。检测一个对象是否是 "
":term:`iterable` 的唯一可信赖的方法是调用 ``iter(obj)``。"

#: ../../library/collections.abc.rst:230
msgid "ABC for sized iterable container classes."
msgstr "集合了 Sized 和 Iterable 类的抽象基类。"

#: ../../library/collections.abc.rst:236
msgid ""
"ABC for classes that provide the :meth:`~iterator.__iter__` and "
":meth:`~iterator.__next__` methods.  See also the definition of "
":term:`iterator`."
msgstr ""
"提供了 :meth:`~iterator.__iter__` 和 :meth:`~iterator.__next__` 方法的抽象基类。参见 "
":term:`iterator` 的定义。"

#: ../../library/collections.abc.rst:242
msgid ""
"ABC for iterable classes that also provide the :meth:`__reversed__` "
"method."
msgstr "为可迭代类提供了 :meth:`__reversed__` 方法的抽象基类。"

#: ../../library/collections.abc.rst:249
msgid ""
"ABC for generator classes that implement the protocol defined in "
":pep:`342` that extends iterators with the :meth:`~generator.send`, "
":meth:`~generator.throw` and :meth:`~generator.close` methods. See also "
"the definition of :term:`generator`."
msgstr ""
"生成器类，实现了 :pep:`342` 中定义的协议，继承并扩展了迭代器，提供了 :meth:`~generator.send`, "
":meth:`~generator.throw` 和 :meth:`~generator.close` 方法。参见 "
":term:`generator` 的定义。"

#: ../../library/collections.abc.rst:260
msgid "ABCs for read-only and mutable :term:`sequences <sequence>`."
msgstr "只读且可变的序列 :term:`sequences <sequence>` 的抽象基类。"

#: ../../library/collections.abc.rst:262
msgid ""
"Implementation note: Some of the mixin methods, such as :meth:`__iter__`,"
" :meth:`__reversed__` and :meth:`index`, make repeated calls to the "
"underlying :meth:`__getitem__` method. Consequently, if "
":meth:`__getitem__` is implemented with constant access speed, the mixin "
"methods will have linear performance; however, if the underlying method "
"is linear (as it would be with a linked list), the mixins will have "
"quadratic performance and will likely need to be overridden."
msgstr ""
"实现笔记：一些混入（Maxin）方法比如 :meth:`__iter__`, :meth:`__reversed__` 和 "
":meth:`index` 会重复调用底层的 :meth:`__getitem__` 方法。因此，如果实现的 "
":meth:`__getitem__` "
"是常数级访问速度，那么相应的混入方法会有一个线性的表现；然而，如果底层方法是线性实现（例如链表），那么混入方法将会是平方级的表现，这也许就需要被重构了。"

#: ../../library/collections.abc.rst:271
msgid "The index() method added support for *stop* and *start* arguments."
msgstr "index() 方法支持 *stop* 和 *start* 参数。"

#: ../../library/collections.abc.rst:278
msgid "ABCs for read-only and mutable sets."
msgstr "只读且可变的集合的抽象基类。"

#: ../../library/collections.abc.rst:283
msgid "ABCs for read-only and mutable :term:`mappings <mapping>`."
msgstr "只读且可变的映射 :term:`mappings <mapping>` 的抽象基类。"

#: ../../library/collections.abc.rst:290
msgid "ABCs for mapping, items, keys, and values :term:`views <dictionary view>`."
msgstr "映射及其键和值的视图 :term:`views <dictionary view>` 的抽象基类。"

#: ../../library/collections.abc.rst:294
msgid ""
"ABC for :term:`awaitable` objects, which can be used in :keyword:`await` "
"expressions.  Custom implementations must provide the :meth:`__await__` "
"method."
msgstr ""
"为可等待对象 :term:`awaitable` 提供的类，可以被用于 :keyword:`await` 表达式中。习惯上必须实现 "
":meth:`__await__` 方法。"

#: ../../library/collections.abc.rst:298
msgid ""
":term:`Coroutine <coroutine>` objects and instances of the "
":class:`~collections.abc.Coroutine` ABC are all instances of this ABC."
msgstr ""
":term:`协程 <coroutine>` 对象和 :class:`~collections.abc.Coroutine` ABC "
"的实例都是这个 ABC 的实例。"

#: ../../library/collections.abc.rst:302
msgid ""
"In CPython, generator-based coroutines (generators decorated with "
":func:`types.coroutine` or :func:`asyncio.coroutine`) are *awaitables*, "
"even though they do not have an :meth:`__await__` method. Using "
"``isinstance(gencoro, Awaitable)`` for them will return ``False``. Use "
":func:`inspect.isawaitable` to detect them."
msgstr ""
"在 CPython 里，基于生成器的协程（使用 :func:`types.coroutine` 或 "
":func:`asyncio.coroutine` 包装的生成器）都是 *可等待对象*，即使他们不含有 :meth:`__await__` "
"方法。使用 ``isinstance(gencoro, Awaitable)`` 来检测他们会返回 ``False``。要使用 "
":func:`inspect.isawaitable` 来检测他们。"

#: ../../library/collections.abc.rst:312
msgid ""
"ABC for coroutine compatible classes.  These implement the following "
"methods, defined in :ref:`coroutine-objects`: :meth:`~coroutine.send`, "
":meth:`~coroutine.throw`, and :meth:`~coroutine.close`.  Custom "
"implementations must also implement :meth:`__await__`.  All "
":class:`Coroutine` instances are also instances of :class:`Awaitable`.  "
"See also the definition of :term:`coroutine`."
msgstr ""
"用于协程兼容类的抽象基类。实现了如下定义在 :ref:`coroutine-objects`: 里的方法： "
":meth:`~coroutine.send`，:meth:`~coroutine.throw` 和 "
":meth:`~coroutine.close`。通常的实现里还需要实现 :meth:`__await__` 方法。所有的 "
":class:`Coroutine` 实例都必须是 :class:`Awaitable` 实例。参见 :term:`coroutine` 的定义。"

#: ../../library/collections.abc.rst:320
msgid ""
"In CPython, generator-based coroutines (generators decorated with "
":func:`types.coroutine` or :func:`asyncio.coroutine`) are *awaitables*, "
"even though they do not have an :meth:`__await__` method. Using "
"``isinstance(gencoro, Coroutine)`` for them will return ``False``. Use "
":func:`inspect.isawaitable` to detect them."
msgstr ""
"在 CPython 里，基于生成器的协程（使用 :func:`types.coroutine` 或 "
":func:`asyncio.coroutine` 包装的生成器）都是 *可等待对象*，即使他们不含有 :meth:`__await__` "
"方法。使用 ``isinstance(gencoro, Coroutine)`` 来检测他们会返回 ``False``。要使用 "
":func:`inspect.isawaitable` 来检测他们。"

#: ../../library/collections.abc.rst:330
msgid ""
"ABC for classes that provide ``__aiter__`` method.  See also the "
"definition of :term:`asynchronous iterable`."
msgstr "提供了 ``__aiter__`` 方法的抽象基类。参见 :term:`asynchronous iterable` 的定义。"

#: ../../library/collections.abc.rst:337
msgid ""
"ABC for classes that provide ``__aiter__`` and ``__anext__`` methods.  "
"See also the definition of :term:`asynchronous iterator`."
msgstr ""
"提供了 ``__aiter__`` 和 ``__anext__`` 方法的抽象基类。参见 :term:`asynchronous "
"iterator` 的定义。"

#: ../../library/collections.abc.rst:344
msgid ""
"ABC for asynchronous generator classes that implement the protocol "
"defined in :pep:`525` and :pep:`492`."
msgstr "为异步生成器类提供的抽象基类，这些类实现了定义在 :pep:`525` 和 :pep:`492` 里的协议。"

#: ../../library/collections.abc.rst:350
msgid "Examples and Recipes"
msgstr ""

#: ../../library/collections.abc.rst:352
#, fuzzy
msgid ""
"ABCs allow us to ask classes or instances if they provide particular "
"functionality, for example::"
msgstr "这些抽象基类让我们可以确定类和示例拥有某些特定的函数，例如："

#: ../../library/collections.abc.rst:359
msgid ""
"Several of the ABCs are also useful as mixins that make it easier to "
"develop classes supporting container APIs.  For example, to write a class"
" supporting the full :class:`Set` API, it is only necessary to supply the"
" three underlying abstract methods: :meth:`__contains__`, "
":meth:`__iter__`, and :meth:`__len__`. The ABC supplies the remaining "
"methods such as :meth:`__and__` and :meth:`isdisjoint`::"
msgstr ""
"有些抽象基类也可以用作混入类（mixin），这可以更容易地开发支持容器 API 的类。例如，要写一个支持完整 :class:`Set` API "
"的类，只需要提供下面这三个方法： :meth:`__contains__`, :meth:`__iter__` 和 "
":meth:`__len__`。抽象基类会补充上其余的方法，比如 :meth:`__and__` 和 :meth:`isdisjoint`::"

#: ../../library/collections.abc.rst:388
msgid "Notes on using :class:`Set` and :class:`MutableSet` as a mixin:"
msgstr "当把 :class:`Set` 和 :class:`MutableSet` 用作混入类时需注意："

#: ../../library/collections.abc.rst:391
msgid ""
"Since some set operations create new sets, the default mixin methods need"
" a way to create new instances from an iterable. The class constructor is"
" assumed to have a signature in the form ``ClassName(iterable)``. That "
"assumption is factored-out to an internal classmethod called "
":meth:`_from_iterable` which calls ``cls(iterable)`` to produce a new "
"set. If the :class:`Set` mixin is being used in a class with a different "
"constructor signature, you will need to override :meth:`_from_iterable` "
"with a classmethod or regular method that can construct new instances "
"from an iterable argument."
msgstr ""
"由于某些集合操作会创建新集合，默认的混入方法需要一种从可迭代对象里创建新实例的方式。 假定类构造器具有 "
"``ClassName(iterable)`` 形式的签名。 这样它将执行一个名为 :meth:`_from_iterable` "
"的内部类方法，该方法会调用 ``cls(iterable)`` 来产生一个新集合。 如果 :class:`Set` "
"混入类在具有不同构造器签名的类中被使用，你将需要通过类方法或常规方法来重载 "
":meth:`_from_iterable`，以便基于可迭代对象参数来构造新的实例。"

#: ../../library/collections.abc.rst:402
msgid ""
"To override the comparisons (presumably for speed, as the semantics are "
"fixed), redefine :meth:`__le__` and :meth:`__ge__`, then the other "
"operations will automatically follow suit."
msgstr ""
"重载比较符时时（想必是为了速度，因为其语义都是固定的），只需要重定义 :meth:`__le__` 和 :meth:`__ge__` "
"函数，然后其他的操作会自动跟进。"

#: ../../library/collections.abc.rst:407
msgid ""
"The :class:`Set` mixin provides a :meth:`_hash` method to compute a hash "
"value for the set; however, :meth:`__hash__` is not defined because not "
"all sets are hashable or immutable.  To add set hashability using mixins,"
" inherit from both :meth:`Set` and :meth:`Hashable`, then define "
"``__hash__ = Set._hash``."
msgstr ""
"混入集合类 :class:`Set` 提供了一个 :meth:`_hash` 方法为集合计算哈希值，然而， :meth:`__hash__` "
"函数却没有被定义，因为并不是所有集合都是可哈希并且不可变的。为了使用混入类为集合添加哈希能力，可以同时继承 :meth:`Set` 和 "
":meth:`Hashable` 类，然后定义 ``__hash__ = Set._hash``。"

#: ../../library/collections.abc.rst:415
msgid ""
"`OrderedSet recipe <https://code.activestate.com/recipes/576694/>`_ for "
"an example built on :class:`MutableSet`."
msgstr ""
"`OrderedSet recipe <https://code.activestate.com/recipes/576694/>`_ 是基于 "
":class:`MutableSet` 构建的一个示例。"

#: ../../library/collections.abc.rst:418
msgid "For more about ABCs, see the :mod:`abc` module and :pep:`3119`."
msgstr "对于抽象基类，参见 :mod:`abc` 模块和 :pep:`3119`。"

